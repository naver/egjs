<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>egjs - API</title>
    
    
    
    
    
    <meta property="og:title" content=""/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content=""/>
    
    <meta property="og:url" content=""/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jaguar.css">
    
    
    <script>
    var config = {"monospaceLinks":true,"cleverLinks":true,"default":{"outputSourceFiles":true},"applicationName":"egjs","disqus":"egjs","googleAnalytics":"","openGraph":{"title":"","type":"website","image":"","site_name":"","url":""},"meta":{"title":"egjs - API","description":"","keyword":""},"linenums":true};
    </script>
    

    
</head>
<body>
<div id="wrap" class="clearfix">
    
<div class="navigation">
    <h3 class="applicationName"><a href="index.html">egjs</a></h3>

    <div class="search">
        <input id="search" type="text" class="form-control input-sm" placeholder="Search Documentations">
    </div>
    <ul class="list">
    
    
        <!-- Grouping Version -->
        <ul class="group">
        <span>egjs</span>
        
            
<li class="item" data-name="eg">
    <span class="title">
        <a href="eg.html">eg</a>
        
        <span class="static">static</span>
        
    </span>
    <ul class="members itemMembers">
    
    <span class="subtitle">Members</span>
    
        <li data-name="eg.VERSION"><a href="eg.html#VERSION">VERSION</a></li>
    
    </ul>
    <ul class="typedefs itemMembers">
    
    </ul>
    <ul class="methods itemMembers">
    
    <span class="subtitle">Methods</span>
    
        <li data-name="eg#agent"><a href="eg.html#agent">agent</a></li>
    
        <li data-name="eg#cancelAnimationFrame"><a href="eg.html#cancelAnimationFrame">cancelAnimationFrame</a></li>
    
        <li data-name="eg#isHWAccelerable"><a href="eg.html#isHWAccelerable">isHWAccelerable</a></li>
    
        <li data-name="eg#isPortrait"><a href="eg.html#isPortrait">isPortrait</a></li>
    
        <li data-name="eg#isTransitional"><a href="eg.html#isTransitional">isTransitional</a></li>
    
        <li data-name="eg#requestAnimationFrame"><a href="eg.html#requestAnimationFrame">requestAnimationFrame</a></li>
    
        <li data-name="eg#translate"><a href="eg.html#translate">translate</a></li>
    
    </ul>
    <ul class="events itemMembers">
    
    </ul>

    

</li>

        
            
<li class="item" data-name="eg.Class">
    <span class="title">
        <a href="eg.Class.html">eg.Class</a>
        
    </span>
    <ul class="members itemMembers">
    
    </ul>
    <ul class="typedefs itemMembers">
    
    </ul>
    <ul class="methods itemMembers">
    
    <span class="subtitle">Methods</span>
    
        <li data-name="eg.Class.extend"><a href="eg.Class.html#extend">extend</a></li>
    
        <li data-name="eg.Class#instance"><a href="eg.Class.html#instance">instance</a></li>
    
    </ul>
    <ul class="events itemMembers">
    
    </ul>

    

</li>

        
            
<li class="item" data-name="eg.Component">
    <span class="title">
        <a href="eg.Component.html">eg.Component</a>
        
    </span>
    <ul class="members itemMembers">
    
    </ul>
    <ul class="typedefs itemMembers">
    
    </ul>
    <ul class="methods itemMembers">
    
    <span class="subtitle">Methods</span>
    
        <li data-name="eg.Component#hasOn"><a href="eg.Component.html#hasOn">hasOn</a></li>
    
        <li data-name="eg.Component#off"><a href="eg.Component.html#off">off</a></li>
    
        <li data-name="eg.Component#on"><a href="eg.Component.html#on">on</a></li>
    
        <li data-name="eg.Component#option"><a href="eg.Component.html#option">option</a></li>
    
        <li data-name="eg.Component#trigger"><a href="eg.Component.html#trigger">trigger</a></li>
    
    </ul>
    <ul class="events itemMembers">
    
    </ul>

    

</li>

        
            
<li class="item" data-name="eg.Flicking">
    <span class="title">
        <a href="eg.Flicking.html">eg.Flicking</a>
        
    </span>
    <ul class="members itemMembers">
    
    </ul>
    <ul class="typedefs itemMembers">
    
    </ul>
    <ul class="methods itemMembers">
    
    <span class="subtitle">Methods</span>
    
        <li data-name="eg.Flicking#getAllElements"><a href="eg.Flicking.html#getAllElements">getAllElements</a></li>
    
        <li data-name="eg.Flicking#getElement"><a href="eg.Flicking.html#getElement">getElement</a></li>
    
        <li data-name="eg.Flicking#getIndex"><a href="eg.Flicking.html#getIndex">getIndex</a></li>
    
        <li data-name="eg.Flicking#getNextElement"><a href="eg.Flicking.html#getNextElement">getNextElement</a></li>
    
        <li data-name="eg.Flicking#getNextIndex"><a href="eg.Flicking.html#getNextIndex">getNextIndex</a></li>
    
        <li data-name="eg.Flicking#getPrevIndex"><a href="eg.Flicking.html#getPrevIndex">getPrevIndex</a></li>
    
        <li data-name="eg.Flicking#getTotalCount"><a href="eg.Flicking.html#getTotalCount">getTotalCount</a></li>
    
        <li data-name="eg.Flicking#hasOn"><a href="eg.Flicking.html#hasOn">hasOn</a></li>
    
        <li data-name="eg.Flicking#isPlaying"><a href="eg.Flicking.html#isPlaying">isPlaying</a></li>
    
        <li data-name="eg.Flicking#moveTo"><a href="eg.Flicking.html#moveTo">moveTo</a></li>
    
        <li data-name="eg.Flicking#next"><a href="eg.Flicking.html#next">next</a></li>
    
        <li data-name="eg.Flicking#off"><a href="eg.Flicking.html#off">off</a></li>
    
        <li data-name="eg.Flicking#on"><a href="eg.Flicking.html#on">on</a></li>
    
        <li data-name="eg.Flicking#option"><a href="eg.Flicking.html#option">option</a></li>
    
        <li data-name="eg.Flicking#prev"><a href="eg.Flicking.html#prev">prev</a></li>
    
        <li data-name="eg.Flicking#resize"><a href="eg.Flicking.html#resize">resize</a></li>
    
        <li data-name="eg.Flicking#restore"><a href="eg.Flicking.html#restore">restore</a></li>
    
        <li data-name="eg.Flicking#trigger"><a href="eg.Flicking.html#trigger">trigger</a></li>
    
    </ul>
    <ul class="events itemMembers">
    
    <span class="subtitle">Events</span>
    
        <li data-name="eg.Flicking#event:beforeFlickStart"><a href="eg.Flicking.html#event:beforeFlickStart">beforeFlickStart</a></li>
    
        <li data-name="eg.Flicking#event:beforeRestore"><a href="eg.Flicking.html#event:beforeRestore">beforeRestore</a></li>
    
        <li data-name="eg.Flicking#event:flick"><a href="eg.Flicking.html#event:flick">flick</a></li>
    
        <li data-name="eg.Flicking#event:flickEnd"><a href="eg.Flicking.html#event:flickEnd">flickEnd</a></li>
    
        <li data-name="eg.Flicking#event:restore"><a href="eg.Flicking.html#event:restore">restore</a></li>
    
    </ul>

    

</li>

        
            
<li class="item" data-name="eg.InfiniteGrid">
    <span class="title">
        <a href="eg.InfiniteGrid.html">eg.InfiniteGrid</a>
        
    </span>
    <ul class="members itemMembers">
    
    </ul>
    <ul class="typedefs itemMembers">
    
    </ul>
    <ul class="methods itemMembers">
    
    <span class="subtitle">Methods</span>
    
        <li data-name="eg.InfiniteGrid#append"><a href="eg.InfiniteGrid.html#append">append</a></li>
    
        <li data-name="eg.InfiniteGrid#clear"><a href="eg.InfiniteGrid.html#clear">clear</a></li>
    
        <li data-name="eg.InfiniteGrid#destroy"><a href="eg.InfiniteGrid.html#destroy">destroy</a></li>
    
        <li data-name="eg.InfiniteGrid#fit"><a href="eg.InfiniteGrid.html#fit">fit</a></li>
    
        <li data-name="eg.InfiniteGrid#getBottomElement"><a href="eg.InfiniteGrid.html#getBottomElement">getBottomElement</a></li>
    
        <li data-name="eg.InfiniteGrid#getGroupKeys"><a href="eg.InfiniteGrid.html#getGroupKeys">getGroupKeys</a></li>
    
        <li data-name="eg.InfiniteGrid#getStatue"><a href="eg.InfiniteGrid.html#getStatue">getStatue</a></li>
    
        <li data-name="eg.InfiniteGrid#getTopElement"><a href="eg.InfiniteGrid.html#getTopElement">getTopElement</a></li>
    
        <li data-name="eg.InfiniteGrid#hasOn"><a href="eg.InfiniteGrid.html#hasOn">hasOn</a></li>
    
        <li data-name="eg.InfiniteGrid#isProcessing"><a href="eg.InfiniteGrid.html#isProcessing">isProcessing</a></li>
    
        <li data-name="eg.InfiniteGrid#isRecycling"><a href="eg.InfiniteGrid.html#isRecycling">isRecycling</a></li>
    
        <li data-name="eg.InfiniteGrid#layout"><a href="eg.InfiniteGrid.html#layout">layout</a></li>
    
        <li data-name="eg.InfiniteGrid#off"><a href="eg.InfiniteGrid.html#off">off</a></li>
    
        <li data-name="eg.InfiniteGrid#on"><a href="eg.InfiniteGrid.html#on">on</a></li>
    
        <li data-name="eg.InfiniteGrid#option"><a href="eg.InfiniteGrid.html#option">option</a></li>
    
        <li data-name="eg.InfiniteGrid#prepend"><a href="eg.InfiniteGrid.html#prepend">prepend</a></li>
    
        <li data-name="eg.InfiniteGrid#setStatus"><a href="eg.InfiniteGrid.html#setStatus">setStatus</a></li>
    
        <li data-name="eg.InfiniteGrid#trigger"><a href="eg.InfiniteGrid.html#trigger">trigger</a></li>
    
    </ul>
    <ul class="events itemMembers">
    
    <span class="subtitle">Events</span>
    
        <li data-name="eg.InfiniteGrid#event:append"><a href="eg.InfiniteGrid.html#event:append">append</a></li>
    
        <li data-name="eg.InfiniteGrid#event:layoutComplete"><a href="eg.InfiniteGrid.html#event:layoutComplete">layoutComplete</a></li>
    
        <li data-name="eg.InfiniteGrid#event:prepend"><a href="eg.InfiniteGrid.html#event:prepend">prepend</a></li>
    
    </ul>

    

</li>

        
            
<li class="item" data-name="eg.MovableCoord">
    <span class="title">
        <a href="eg.MovableCoord.html">eg.MovableCoord</a>
        
    </span>
    <ul class="members itemMembers">
    
    <span class="subtitle">Members</span>
    
        <li data-name="eg.MovableCoord.DIRECTION_ALL"><a href="eg.MovableCoord.html#DIRECTION_ALL">DIRECTION_ALL</a></li>
    
        <li data-name="eg.MovableCoord.DIRECTION_DOWN"><a href="eg.MovableCoord.html#DIRECTION_DOWN">DIRECTION_DOWN</a></li>
    
        <li data-name="eg.MovableCoord.DIRECTION_HORIZONTAL"><a href="eg.MovableCoord.html#DIRECTION_HORIZONTAL">DIRECTION_HORIZONTAL</a></li>
    
        <li data-name="eg.MovableCoord.DIRECTION_LEFT"><a href="eg.MovableCoord.html#DIRECTION_LEFT">DIRECTION_LEFT</a></li>
    
        <li data-name="eg.MovableCoord.DIRECTION_NONE"><a href="eg.MovableCoord.html#DIRECTION_NONE">DIRECTION_NONE</a></li>
    
        <li data-name="eg.MovableCoord.DIRECTION_RIGHT"><a href="eg.MovableCoord.html#DIRECTION_RIGHT">DIRECTION_RIGHT</a></li>
    
        <li data-name="eg.MovableCoord.DIRECTION_UP"><a href="eg.MovableCoord.html#DIRECTION_UP">DIRECTION_UP</a></li>
    
        <li data-name="eg.MovableCoord.DIRECTION_VERTICAL"><a href="eg.MovableCoord.html#DIRECTION_VERTICAL">DIRECTION_VERTICAL</a></li>
    
    </ul>
    <ul class="typedefs itemMembers">
    
    </ul>
    <ul class="methods itemMembers">
    
    <span class="subtitle">Methods</span>
    
        <li data-name="eg.MovableCoord#bind"><a href="eg.MovableCoord.html#bind">bind</a></li>
    
        <li data-name="eg.MovableCoord#destroy"><a href="eg.MovableCoord.html#destroy">destroy</a></li>
    
        <li data-name="eg.MovableCoord#get"><a href="eg.MovableCoord.html#get">get</a></li>
    
        <li data-name="eg.MovableCoord#hasOn"><a href="eg.MovableCoord.html#hasOn">hasOn</a></li>
    
        <li data-name="eg.MovableCoord#off"><a href="eg.MovableCoord.html#off">off</a></li>
    
        <li data-name="eg.MovableCoord#on"><a href="eg.MovableCoord.html#on">on</a></li>
    
        <li data-name="eg.MovableCoord#option"><a href="eg.MovableCoord.html#option">option</a></li>
    
        <li data-name="eg.MovableCoord#setBy"><a href="eg.MovableCoord.html#setBy">setBy</a></li>
    
        <li data-name="eg.MovableCoord#setTo"><a href="eg.MovableCoord.html#setTo">setTo</a></li>
    
        <li data-name="eg.MovableCoord#trigger"><a href="eg.MovableCoord.html#trigger">trigger</a></li>
    
        <li data-name="eg.MovableCoord#unbind"><a href="eg.MovableCoord.html#unbind">unbind</a></li>
    
    </ul>
    <ul class="events itemMembers">
    
    <span class="subtitle">Events</span>
    
        <li data-name="eg.MovableCoord#event:animationEnd"><a href="eg.MovableCoord.html#event:animationEnd">animationEnd</a></li>
    
        <li data-name="eg.MovableCoord#event:animationStart"><a href="eg.MovableCoord.html#event:animationStart">animationStart</a></li>
    
        <li data-name="eg.MovableCoord#event:change"><a href="eg.MovableCoord.html#event:change">change</a></li>
    
        <li data-name="eg.MovableCoord#event:hold"><a href="eg.MovableCoord.html#event:hold">hold</a></li>
    
        <li data-name="eg.MovableCoord#event:release"><a href="eg.MovableCoord.html#event:release">release</a></li>
    
    </ul>

    

</li>

        
            
<li class="item" data-name="eg.Visible">
    <span class="title">
        <a href="eg.Visible.html">eg.Visible</a>
        
    </span>
    <ul class="members itemMembers">
    
    </ul>
    <ul class="typedefs itemMembers">
    
    </ul>
    <ul class="methods itemMembers">
    
    <span class="subtitle">Methods</span>
    
        <li data-name="eg.Visible#check"><a href="eg.Visible.html#check">check</a></li>
    
        <li data-name="eg.Visible#hasOn"><a href="eg.Visible.html#hasOn">hasOn</a></li>
    
        <li data-name="eg.Visible#off"><a href="eg.Visible.html#off">off</a></li>
    
        <li data-name="eg.Visible#on"><a href="eg.Visible.html#on">on</a></li>
    
        <li data-name="eg.Visible#option"><a href="eg.Visible.html#option">option</a></li>
    
        <li data-name="eg.Visible#refresh"><a href="eg.Visible.html#refresh">refresh</a></li>
    
        <li data-name="eg.Visible#trigger"><a href="eg.Visible.html#trigger">trigger</a></li>
    
    </ul>
    <ul class="events itemMembers">
    
    <span class="subtitle">Events</span>
    
        <li data-name="eg.Visible#event:change"><a href="eg.Visible.html#event:change">change</a></li>
    
    </ul>

    

</li>

        
        </ul>
    
        <!-- Grouping Version -->
        <ul class="group">
        <span>jQuery Extension</span>
        
            
<li class="item" data-name="jQuery">
    <span class="title">
        <a href="jQuery.html">jQuery</a>
        
        <span class="static">static</span>
        
    </span>
    <ul class="members itemMembers">
    
    </ul>
    <ul class="typedefs itemMembers">
    
    </ul>
    <ul class="methods itemMembers">
    
    <span class="subtitle">Methods</span>
    
        <li data-name="jQuery.flicking"><a href="jQuery.html#flicking">flicking</a></li>
    
        <li data-name="jQuery.infiniteGrid"><a href="jQuery.html#infiniteGrid">infiniteGrid</a></li>
    
        <li data-name="jQuery.persist"><a href="jQuery.html#persist">persist</a></li>
    
        <li data-name="jQuery.persist"><a href="jQuery.html#persist">persist</a></li>
    
        <li data-name="jQuery.persist"><a href="jQuery.html#persist">persist</a></li>
    
        <li data-name="jQuery.persist"><a href="jQuery.html#persist">persist</a></li>
    
        <li data-name="jQuery.visible"><a href="jQuery.html#visible">visible</a></li>
    
        <li data-name="jQuery#animate"><a href="jQuery.html#animate">animate</a></li>
    
    </ul>
    <ul class="events itemMembers">
    
    <span class="subtitle">Events</span>
    
        <li data-name="jQuery#event:rotate"><a href="jQuery.html#event:rotate">rotate</a></li>
    
        <li data-name="jQuery#event:scrollEnd"><a href="jQuery.html#event:scrollEnd">scrollEnd</a></li>
    
        <li data-name="jQuery#flicking:beforeFlickStart"><a href="jQuery.html#event:flicking:beforeFlickStart">flicking:beforeFlickStart</a></li>
    
        <li data-name="jQuery#flicking:beforeRestore"><a href="jQuery.html#event:flicking:beforeRestore">flicking:beforeRestore</a></li>
    
        <li data-name="jQuery#flicking:flick"><a href="jQuery.html#event:flicking:flick">flicking:flick</a></li>
    
        <li data-name="jQuery#flicking:flickEnd"><a href="jQuery.html#event:flicking:flickEnd">flicking:flickEnd</a></li>
    
        <li data-name="jQuery#flicking:restore"><a href="jQuery.html#event:flicking:restore">flicking:restore</a></li>
    
        <li data-name="jQuery#infiniteGrid:append"><a href="jQuery.html#event:infiniteGrid:append">infiniteGrid:append</a></li>
    
        <li data-name="jQuery#infiniteGrid:layoutComplete"><a href="jQuery.html#event:infiniteGrid:layoutComplete">infiniteGrid:layoutComplete</a></li>
    
        <li data-name="jQuery#infiniteGrid:prepend"><a href="jQuery.html#event:infiniteGrid:prepend">infiniteGrid:prepend</a></li>
    
        <li data-name="jQuery#visible:change"><a href="jQuery.html#event:visible:change">visible:change</a></li>
    
    </ul>

    

</li>

        
        </ul>
    
    </ul>
</div>

    <div class="main">
        <h1 class="page-title" data-filename="movableCoord.js.html">Source: movableCoord.js</h1>
        


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
* Copyright (c) 2015 NAVER Corp.
* egjs projects are licensed under the MIT license
*/

// jscs:disable maximumLineLength
eg.module("movableCoord", ["jQuery", eg, window, "Hammer"], function($, ns, global, HM) {
	"use strict";

	var SUPPORT_TOUCH = "ontouchstart" in global;

	// jscs:enable maximumLineLength
	// It is scheduled to be removed in case of build process.
	// ns.__checkLibrary__( !("Hammer" in window), "You must download Hammerjs. (http://hammerjs.github.io/)\n\ne.g. bower install hammerjs");
	// ns.__checkLibrary__( !("easeOutQuint" in $.easing), "You must download jQuery Easing Plugin(http://gsgd.co.uk/sandbox/jquery/easing/)\n\ne.g. bower install jquery.easing");
	/**
	 * Easily get computed coordinate values according user actions.
	 * @group egjs
	 * @ko MovableCoord는 사용자 행동에 의해, 좌표계를 제어할 수 있다.
	 * @class
	 * @name eg.MovableCoord
	 * @extends eg.Component
	 *
	 * @param {Object} options
	 * @param {Array} options.min The minimum coordinate  &lt;ko>좌표계의 최소값&lt;/ko>
	 * @param {Number} [options.min.0=0] The minimum x-coordinate &lt;ko>최소 X좌표&lt;/ko>
	 * @param {Number} [options.min.1=0] The minimum y-coordinate &lt;ko>최소 Y좌표&lt;/ko>
	 *
	 * @param {Array} options.max The maximum coordinate &lt;ko>좌표계의 최대값&lt;/ko>
	 * @param {Number} [options.max.0=100] The maximum x-coordinate &lt;ko>최대 X좌표&lt;/ko>
	 * @param {Number} [options.max.1=100] The maximum y-coordinate &lt;ko>최대 Y좌표&lt;/ko>
	 *
	 * @param {Array} options.bounce The area can move using animation. &lt;ko>바운스: 애니메이션에 의해 이동할 수 있는 영역 &lt;/ko>
	 * @param {Boolean} [options.bounce.0=10] The bounce top range &lt;ko>top 바우스 영역&lt;/ko>
	 * @param {Boolean} [options.bounce.1=10] The bounce right range &lt;ko>right 바우스 영역&lt;/ko>
	 * @param {Boolean} [options.bounce.2=10] The bounce bottom range &lt;ko>bottom 바우스 영역&lt;/ko>
	 * @param {Boolean} [options.bounce.3=10] The bounce left range &lt;ko>left 바우스 영역&lt;/ko>
	 *
	 * @param {Array} options.margin The area can move using user's action. &lt;ko>영역별 마진 영역: 사용자의 액션에 의해, 추가로 이동할수 있는 영역&lt;/ko>
	 * @param {Boolean} [options.margin.0=0] The margin top range &lt;ko>top 마진 영역&lt;/ko>
	 * @param {Boolean} [options.margin.1=0] The margin right range &lt;ko>right 마진 영역&lt;/ko>
	 * @param {Boolean} [options.margin.2=0] The margin bottom range &lt;ko>bottom 마진 영역&lt;/ko>
	 * @param {Boolean} [options.margin.3=0] The margin left range &lt;ko>left 마진 영역&lt;/ko>
	 * @param {Array} options.circular &lt;ko>영역별 순환 여부&lt;/ko>
	 * @param {Boolean} [options.circular.0=false] The circular top range &lt;ko>top 순환 영역&lt;/ko>
	 * @param {Boolean} [options.circular.1=false] The circular right range &lt;ko>right 순환 영역&lt;/ko>
	 * @param {Boolean} [options.circular.2=false] The circular bottom range &lt;ko>bottom 순환 영역&lt;/ko>
	 * @param {Boolean} [options.circular.3=false] The circular left range &lt;ko>left 순환 영역&lt;/ko>
	 *
	 * @param {Function} [options.easing=easing.easeOutCubic] Function of the Easing (jQuery UI Easing, jQuery Easing Plugin). &lt;ko>Easing 함수&lt;/ko>
	 * @param {Number} [options.maximumDuration=Infinity] The maximum duration. &lt;ko>최대 좌표 이동 시간&lt;/ko>
	 * @param {Number} [options.deceleration=0.0006] deceleration This value can be altered to change the momentum animation duration. higher numbers make the animation shorter. &lt;ko>감속계수. 높을값이 주어질수록 애니메이션의 동작 시간이 짧아진다.&lt;/ko>
	 * @see Hammerjs {@link http://hammerjs.github.io}
	 * @see There is usability issue due to default CSS properties ({@link http://hammerjs.github.io/jsdoc/Hammer.defaults.cssProps.html}) settings from Hammerjs. movableCoord removes that settings to fix.
	 * &lt;ko>Hammerjs의 기본 CSS 속성({@link http://hammerjs.github.io/jsdoc/Hammer.defaults.cssProps.html}) 으로 인해 사용성 이슈가 있다. 따라서, movableCoord는 hammerjs의 기본 CSS 속성을 제거하였다.&lt;/ko>
	 *
	 * @codepen {"id":"bdVybg", "ko":"MovableCoord 기본 예제", "en":"MovableCoord basic example", "collectionId":"AKpkGW", "height": 403}
	 *
	 * @see Easing Functions Cheat Sheet {@link http://easings.net/}
	 * @see To use other easing functions, import jQuery easing plugin({@link http://gsgd.co.uk/sandbox/jquery/easing/}) or jQuery UI easing.({@link https://jqueryui.com/easing/})&lt;ko>다른 easing 함수를 사용하고 싶다면, jQuery easing plugin({@link http://gsgd.co.uk/sandbox/jquery/easing/})이나, jQuery UI easing({@link https://jqueryui.com/easing/}) 라이브러리를 삽입해야 한다.&lt;/ko>
	 *
	 * @support {"ie": "10+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "ios" : "7+", "an" : "2.3+ (except 3.x)"}
	 */
	var MC = ns.MovableCoord = ns.Class.extend(ns.Component, {
		construct: function(options) {
			this.options = {
				min: [0, 0],
				max: [100, 100],
				bounce: [10, 10, 10, 10],
				margin: [0,0,0,0],
				circular: [false, false, false, false],
				easing: $.easing.easeOutCubic,
				maximumDuration: Infinity,
				deceleration: 0.0006
			};
			this._reviseOptions(options);
			this._status = {
				grabOutside: false,		// check whether user's action started on outside
				curHammer: null,		// current hammer instance
				moveDistance: null,		// a position of the first user's action
				animationParam: null,	// animation information
				prevented: false		//  check whether the animation event was prevented
			};
			this._hammers = {};
			this._pos = this.options.min.concat();
			this._subOptions = {};
			this._raf = null;
			this._animationEnd = $.proxy(this._animationEnd, this);	// for caching
			this._panmove = $.proxy(this._panmove, this);	// for caching
			this._panend = $.proxy(this._panend, this);	// for caching
		},
		/**
		 * Bind element
		 * @ko movableCoord을 사용하기 위한 엘리먼트를 등록한다.
		 * @method eg.MovableCoord#bind
		 * @param {HTMLElement|String|jQuery} element  A target element. &lt;ko>movableCoord을 사용하기 위한 엘리먼트&lt;/ko>
		 * @param {Object} options
		 * @param {Number} [options.direction=eg.MovableCoord.DIRECTION_ALL] The controllable directions. &lt;ko>움직일수 있는 방향&lt;/ko>
		 * @param {Array} options.scale The moving scale. &lt;ko>이동 배율&lt;/ko>
		 * @param {Number} [options.scale.0=1] x-scale &lt;ko>x축 배율&lt;/ko>
		 * @param {Number} [options.scale.1=1] y-scale &lt;ko>y축 배율&lt;/ko>
		 * @param {Number} [options.thresholdAngle=45] The threshold angle about direction which range is 0~90 &lt;ko>방향에 대한 임계각 (0~90)&lt;/ko>
		 * @param {Number} [options.interruptable=true] interruptable This value can be enabled to interrupt cycle of the animation event. &lt;ko>이 값이  true이면, 애니메이션의 이벤트 사이클을 중단할수 있다.&lt;/ko>
		 * @param {Array} [options.inputType] inputType you can control input type. a kind of inputs are "touch", "mouse".  default value is ["touch", "mouse"] &lt;ko>입력 타입을 지정할수 있다. 입력타입은 "touch", "mouse" 가 있으며, 배열로 입력할 수 있다. (기본값은 ["touch", "mouse"] 이다)&lt;/ko>
		 *
		 * @return {eg.MovableCoord} instance of itself&lt;ko>자신의 인스턴스&lt;/ko>
		 */
		bind: function(el, options) {
			var $el = $(el);
			var keyValue = $el.data(MC._KEY);
			var subOptions = {
				direction: MC.DIRECTION_ALL,
				scale: [ 1, 1 ],
				thresholdAngle: 45,
				interruptable: true,
				inputType: [ "touch", "mouse" ]
			};

			$.extend(subOptions, options);

			var inputClass = this._convertInputType(subOptions.inputType);
			if (!inputClass) {
				return this;
			}
			if (keyValue) {
				this._hammers[keyValue].get("pan").set({
					direction: subOptions.direction
				});
			} else {
				keyValue = Math.round(Math.random() * new Date().getTime());
				this._hammers[keyValue] = this._createHammer(
					$el.get(0),
					subOptions,
					inputClass
				);
				$el.data(MC._KEY, keyValue);
			}
			return this;
		},

		_createHammer: function(el, subOptions, inputClass) {
			try {
				// create Hammer
				var hammer = new HM.Manager(el, {
						recognizers: [
							[
								HM.Tap, {

									// for long tap
									time: 30000
								}
							],
							[
								HM.Pan, {
									direction: subOptions.direction,
									threshold: 0
								}, ["tap"]
							]
						],

						// css properties were removed due to usablility issue
						// http://hammerjs.github.io/jsdoc/Hammer.defaults.cssProps.html
						cssProps: {
							userSelect: "none",
							touchSelect: "none",
							touchCallout: "none",
							userDrag: "none"
						},
						inputClass: inputClass
					});
				return hammer.on("hammer.input", $.proxy(function(e) {
					if (e.isFirst) {
						// apply options each
						this._subOptions = subOptions;
						this._status.curHammer = hammer;
						this._panstart(e);
					}
				}, this))
				.on("panstart panmove", this._panmove)
				.on("panend tap", this._panend);
			} catch (e) {}
		},

		_convertInputType: function(inputType) {
			var hasTouch = false;
			var hasMouse = false;
			inputType = inputType || [];
			$.each(inputType, function(i, v) {
				switch (v) {
					case "mouse" : hasMouse = true; break;
					case "touch" : hasTouch = SUPPORT_TOUCH;
				}
			});

			return hasTouch && HM.TouchInput || hasMouse && HM.MouseInput || null;
		},

		/**
		 * Unbind element
		 * @ko movableCoord을 사용하기 위한 엘리먼트를 해제한다.
		 * @method eg.MovableCoord#unbind
		 * @param {HTMLElement|String|jQuery} element The target element.&lt;ko>movableCoord을 사용하기 위한 설정한 엘리먼트&lt;/ko>
		 * @return {eg.MovableCoord} instance of itself&lt;ko>자신의 인스턴스&lt;/ko>
		 */
		unbind: function(el) {
			var $el = $(el);
			var key = $el.data(MC._KEY);
			if (key) {
				this._hammers[key].destroy();
				delete this._hammers[key];
				$el.data(MC._KEY, null);
			}
			return this;
		},

		_grab: function() {
			if (this._status.animationParam) {
				var pos = this._getCircularPos(this._pos);
				if (pos[0] !== this._pos[0] || pos[1] !== this._pos[1]) {
					this._pos = pos;
					this._triggerChange(this._pos, true);
				}
				this._status.animationParam = null;
				this._raf && ns.cancelAnimationFrame(this._raf);
				this._raf = null;
			}
		},

		_getCircularPos: function(pos, min, max, circular) {
			min = min || this.options.min;
			max = max || this.options.max;
			circular = circular || this.options.circular;

			if (circular[0] && pos[1] &lt; min[1]) { // up
				pos[1] = (pos[1] - min[1]) % (max[1] - min[1] + 1) + max[1];
			}
			if (circular[1] && pos[0] > max[0]) { // right
				pos[0] = (pos[0] - min[0]) % (max[0] - min[0] + 1) + min[0];
			}
			if (circular[2] && pos[1] > max[1]) { // down
				pos[1] = (pos[1] - min[1]) % (max[1] - min[1] + 1) + min[1];
			}
			if (circular[3] && pos[0] &lt; min[0]) { // left
				pos[0] = (pos[0] - min[0]) % (max[0] - min[0] + 1) + max[0];
			}
			pos[0] = +pos[0].toFixed(5), pos[1] = +pos[1].toFixed(5);

			return pos;
		},

		// determine outside
		_isOutside: function(pos, min, max) {
			return pos[0] &lt; min[0] || pos[1] &lt; min[1] ||
				pos[0] > max[0] || pos[1] > max[1];
		},

		// from outside to outside
		_isOutToOut: function(pos, destPos, min, max) {
			return (pos[0] &lt; min[0] || pos[0] > max[0] ||
				pos[1] &lt; min[1] || pos[1] > max[1]) &&
				(destPos[0] &lt; min[0] || destPos[0] > max[0] ||
				destPos[1] &lt; min[1] || destPos[1] > max[1]);
		},

		// panstart event handler
		_panstart: function(e) {
			if (!this._subOptions.interruptable && this._status.prevented) {
				return;
			}
			this._setInterrupt(true);
			var pos = this._pos;
			this._grab();
			/**
			 * When an area was pressed
			 * @ko 스크린에서 사용자가 손을 대었을 때
			 * @name eg.MovableCoord#hold
			 * @event
			 * @param {Object} param
			 * @param {Array} param.pos coordinate &lt;ko>좌표 정보&lt;/ko>
			 * @param {Number} param.pos.0 x-coordinate &lt;ko>x 좌표&lt;/ko>
			 * @param {Number} param.pos.1 y-coordinate &lt;ko>y 좌표&lt;/ko>
			 * @param {Object} param.hammerEvent Hammerjs event. if you use api, this value is null. http://hammerjs.github.io/api/#hammer.input-event &lt;ko>사용자의 액션에 대한 hammerjs 이벤트 정보 (API에 의해 호출될 경우, null 을 반환)&lt;/ko>
			 *
			 */
			this.trigger("hold", {
				pos: pos.concat(),
				hammerEvent: e
			});
			this._status.moveDistance = pos.concat();
			this._status.grabOutside = this._isOutside(
				pos,
				this.options.min,
				this.options.max
			);
		},

		// panmove event handler
		_panmove: function(e) {
			if (!this._isInterrupting() || !this._status.moveDistance) {
				return;
			}
			var tv;
			var tn;
			var tx;
			var pos = this._pos;
			var min = this.options.min;
			var max = this.options.max;
			var bounce = this.options.bounce;
			var margin = this.options.margin;
			var direction = this._subOptions.direction;
			var scale = this._subOptions.scale;
			var userDirection = this._getDirection(e.angle);
			var out = [
				margin[0] + bounce[0],
				margin[1] + bounce[1],
				margin[2] + bounce[2],
				margin[3] + bounce[3]
			];
			var prevent  = false;

			// not support offset properties in Hammerjs - start
			var prevInput = this._status.curHammer.session.prevInput;
			if (prevInput) {
				e.offsetX = e.deltaX - prevInput.deltaX;
				e.offsetY = e.deltaY - prevInput.deltaY;
			} else {
				e.offsetX = e.offsetY = 0;
			}

			// not support offset properties in Hammerjs - end
			if (direction === MC.DIRECTION_ALL ||
				(direction & MC.DIRECTION_HORIZONTAL &&
				userDirection & MC.DIRECTION_HORIZONTAL)
			) {
				this._status.moveDistance[0] += (e.offsetX * scale[0]);
				prevent = true;
			}
			if (direction === MC.DIRECTION_ALL ||
				(direction & MC.DIRECTION_VERTICAL &&
				userDirection & MC.DIRECTION_VERTICAL)
			) {
				this._status.moveDistance[1] += (e.offsetY * scale[1]);
				prevent = true;
			}
			if (prevent) {
				e.srcEvent.preventDefault();
				e.srcEvent.stopPropagation();
			}

			e.preventSystemEvent = prevent;
			pos[0] = this._status.moveDistance[0];
			pos[1] = this._status.moveDistance[1];
			pos = this._getCircularPos(pos, min, max);

			// from outside to inside
			if (this._status.grabOutside && !this._isOutside(pos, min, max)) {
				this._status.grabOutside = false;
			}

			// when move pointer is held in outside
			if (this._status.grabOutside) {
				tn = min[0] - out[3], tx = max[0] + out[1], tv = pos[0];
				pos[0] = tv > tx ? tx : (tv &lt; tn ? tn : tv);
				tn = min[1] - out[0], tx = max[1] + out[2], tv = pos[1];
				pos[1] = tv > tx ? tx : (tv &lt; tn ? tn : tv);
			} else {

				// when start pointer is held in inside
				// get a initialization slope value to prevent smooth animation.
				var initSlope = this._initSlope();
				if (pos[1] &lt; min[1]) { // up
					tv = (min[1] - pos[1]) / (out[0] * initSlope);
					pos[1] = min[1] - this._easing(tv) * out[0];
				} else if (pos[1] > max[1]) { // down
					tv = (pos[1] - max[1]) / (out[2] * initSlope);
					pos[1] = max[1] + this._easing(tv) * out[2];
				}
				if (pos[0] &lt; min[0]) { // left
					tv = (min[0] - pos[0]) / (out[3] * initSlope);
					pos[0] = min[0] - this._easing(tv) * out[3];
				} else if (pos[0] > max[0]) { // right
					tv = (pos[0] - max[0]) / (out[1] * initSlope);
					pos[0] = max[0] + this._easing(tv) * out[1];
				}

			}
			this._triggerChange(pos, true, e);
		},

		// panend event handler
		_panend: function(e) {
			var pos = this._pos;

			if (!this._isInterrupting() || !this._status.moveDistance) {
				return;
			}

			// Abort the animating post process when "tap" occurs
			if (e.type === "tap") {
				this._setInterrupt(false);
				this.trigger("release", {
					depaPos: pos.concat(),
					destPos: pos.concat(),
					hammerEvent: e || null
				});
			} else {
				var direction = this._subOptions.direction;
				var scale = this._subOptions.scale;
				var vX =  Math.abs(e.velocityX);
				var vY = Math.abs(e.velocityY);

				// console.log(e.velocityX, e.velocityY, e.deltaX, e.deltaY);
				!(direction & MC.DIRECTION_HORIZONTAL) && (vX = 0);
				!(direction & MC.DIRECTION_VERTICAL) && (vY = 0);

				this._animateBy(
					this._getNextOffsetPos([
						vX * (e.deltaX &lt; 0 ? -1 : 1) * scale[0],
						vY * (e.deltaY &lt; 0 ? -1 : 1) * scale[1]
					]),
				this._animationEnd, false, null, e);
			}
			this._status.moveDistance = null;
		},

		_isInterrupting: function() {
			// when interruptable is 'true', return value is always 'true'.
			return this._subOptions.interruptable || this._status.prevented;
		},

		// get user's direction
		_getDirection: function(angle) {
			var thresholdAngle = this._subOptions.thresholdAngle;
			if (thresholdAngle &lt; 0 || thresholdAngle > 90) {
				return MC.DIRECTION_NONE;
			}
			angle = Math.abs(angle);
			return angle > thresholdAngle && angle &lt; 180 - thresholdAngle ?
					MC.DIRECTION_VERTICAL : MC.DIRECTION_HORIZONTAL;
		},

		_animationEnd: function() {
			/**
			 * When animation was ended.
			 * @ko 에니메이션이 끝났을 때 발생한다.
			 * @name eg.MovableCoord#animationEnd
			 * @event
			 */
			var pos = this._pos;
			var min = this.options.min;
			var max = this.options.max;
			this._animateTo([
				Math.min(max[0], Math.max(min[0], pos[0])),
				Math.min(max[1], Math.max(min[1], pos[1]))
			], $.proxy(this.trigger, this, "animationEnd"), true, null);
		},

		_getNextOffsetPos: function(speeds) {
			var normalSpeed = Math.sqrt(
				speeds[0] * speeds[0] + speeds[1] * speeds[1]
			);
			var duration = Math.abs(normalSpeed / -this.options.deceleration);
			return [
				speeds[0] / 2 * duration,
				speeds[1] / 2 * duration
			];
		},

		_getDurationFromPos: function(pos) {
			var normalPos = Math.sqrt(pos[0] * pos[0] + pos[1] * pos[1]);
			var duration = Math.sqrt(
				normalPos / this.options.deceleration * 2
			);

			// when duration is under 100, then value is zero
			return duration &lt; 100 ? 0 : duration;
		},

		_animateBy: function(offset, callback, isBounce, duration, e) {
			var pos = this._pos;
			return this._animateTo([
				pos[0] + offset[0],
				pos[1] + offset[1]
			], callback, isBounce, duration, e);
		},

		_getPointOfIntersection: function(depaPos, destPos) {
			var circular = this.options.circular;
			var bounce = this.options.bounce;
			var min = this.options.min;
			var max = this.options.max;
			var boxLT = [ min[0] - bounce[3], min[1] - bounce[0] ];
			var boxRB = [ max[0] + bounce[1], max[1] + bounce[2] ];
			var xd;
			var yd;
			destPos = [destPos[0], destPos[1]];
			xd = destPos[0] - depaPos[0], yd = destPos[1] - depaPos[1];
			if (!circular[3]) {
				destPos[0] = Math.max(boxLT[0], destPos[0]);
			} // left
			if (!circular[1]) {
				destPos[0] = Math.min(boxRB[0], destPos[0]);
			} // right
			destPos[1] = xd ?
							depaPos[1] + yd / xd * (destPos[0] - depaPos[0]) :
							destPos[1];

			if (!circular[0]) {
				destPos[1] = Math.max(boxLT[1], destPos[1]);
			} // up
			if (!circular[2]) {
				destPos[1] = Math.min(boxRB[1], destPos[1]);
			} // down
			destPos[0] = yd ?
							depaPos[0] + xd / yd * (destPos[1] - depaPos[1]) :
							destPos[0];
			return destPos;

		},

		_isCircular: function(circular, destPos, min, max) {
			return (circular[0] && destPos[1] &lt; min[1]) ||
					(circular[1] && destPos[0] > max[0]) ||
					(circular[2] && destPos[1] > max[1]) ||
					(circular[3] && destPos[0] &lt; min[0]);
		},

		_animateTo: function(absPos, callback, isBounce, duration, e) {
			var pos = this._pos;
			var destPos = this._getPointOfIntersection(pos, absPos);
			var param = {
					depaPos: pos.concat(),
					destPos: destPos,
					hammerEvent: e || null
				};
			if (!isBounce && e) {	// check whether user's action
				/**
				 * When an area was released
				 * @ko 스크린에서 사용자가 손을 떼었을 때
				 * @name eg.MovableCoord#release
				 * @event
				 *
				 * @param {Object} param
				 * @param {Array} param.depaPos departure coordinate &lt;ko>현재 좌표&lt;/ko>
				 * @param {Number} param.depaPos.0 departure x-coordinate &lt;ko>현재 x 좌표&lt;/ko>
				 * @param {Number} param.depaPos.1 departure y-coordinate &lt;ko>현재 y 좌표&lt;/ko>
				 * @param {Array} param.destPos destination coordinate &lt;ko>애니메이션에 의해 이동할 좌표&lt;/ko>
				 * @param {Number} param.destPos.0 destination x-coordinate &lt;ko>x 좌표&lt;/ko>
				 * @param {Number} param.destPos.1 destination y-coordinate &lt;ko>y 좌표&lt;/ko>
				 * @param {Object} param.hammerEvent Hammerjs event. if you use api, this value is null. http://hammerjs.github.io/api/#hammer.input-event &lt;ko>사용자의 액션에 대한 hammerjs 이벤트 정보 (API에 의해 호출될 경우, null 을 반환)&lt;/ko>
				 *
				 */
				this.trigger("release", param);
			}
			this._afterReleaseProcess(param, callback, isBounce, duration);
		},

		// when user release a finger, pointer or mouse
		_afterReleaseProcess: function(param, callback, isBounce, duration) {
			// caution: update option values, due to value was changed by "release" event
			var pos = this._pos;
			var min = this.options.min;
			var max = this.options.max;
			var circular = this.options.circular;
			var isCircular = this._isCircular(
								circular,
								param.destPos,
								min,
								max
							);
			var destPos = this._isOutToOut(pos, param.destPos, min, max) ?
				pos : param.destPos;
			var distance = [
				Math.abs(destPos[0] - pos[0]),
				Math.abs(destPos[1] - pos[1])
			];
			var animationParam;
			duration = duration === null ?
						this._getDurationFromPos(distance) : duration;
			duration = this.options.maximumDuration > duration ?
						duration : this.options.maximumDuration;

			var done = $.proxy(function(isNext) {
					this._status.animationParam = null;
					pos[0] = Math.round(destPos[0]);
					pos[1] = Math.round(destPos[1]);
					pos = this._getCircularPos(pos, min, max, circular);
					!isNext && this._setInterrupt(false);
					callback();
				}, this);

			if (distance[0] === 0 && distance[1] === 0) {
				return done(!isBounce);
			}

			// prepare animation parameters
			animationParam = {
				duration: duration,
				depaPos: pos.concat(),
				destPos: destPos,
				isBounce: isBounce,
				isCircular: isCircular,
				done: done,
				hammerEvent: param.hammerEvent
			};

			/**
			 * When animation was started.
			 * @ko 에니메이션이 시작했을 때 발생한다.
			 * @name eg.MovableCoord#animationStart
			 * @event
			 * @param {Object} param
			 * @param {Number} param.duration
			 * @param {Array} param.depaPos departure coordinate &lt;ko>현재 좌표&lt;/ko>
			 * @param {Number} param.depaPos.0 departure x-coordinate &lt;ko>현재 x 좌표&lt;/ko>
			 * @param {Number} param.depaPos.1 departure y-coordinate &lt;ko>현재 y 좌표&lt;/ko>
			 * @param {Array} param.destPos destination coordinate &lt;ko>애니메이션에 의해 이동할 좌표&lt;/ko>
			 * @param {Number} param.destPos.0 destination x-coordinate &lt;ko>x 좌표&lt;/ko>
			 * @param {Number} param.destPos.1 destination y-coordinate &lt;ko>y 좌표&lt;/ko>
			 * @param {Boolean} param.isBounce When an animation is bounced, a value is 'true'.  &lt;ko>바운스 되는 애니메이션인 경우 true&lt;/ko>
			 * @param {Boolean} param.isCircular When the area is circular type, a value is 'true'. &lt;ko>순환하여 움직여야하는 애니메이션인경우 true&lt;/ko>
			 * @param {Function} param.done If user control animation, user must call this function. &lt;ko>애니메이션이 끝났다는 것을 알려주는 함수&lt;/ko>
			 * @param {Object} param.hammerEvent Hammerjs event. if you use api, this value is null. http://hammerjs.github.io/api/#hammer.input-event &lt;ko>사용자의 액션에 대한 hammerjs 이벤트 정보 (API에 의해 호출될 경우, null 을 반환)&lt;/ko>
			 *
			 */
			var retTrigger = this.trigger("animationStart", animationParam);

			// You can't stop the 'animationStart' event when 'circular' is true.
			if (isCircular && !retTrigger) {
				throw new Error(
					"You can't stop the 'animation' event when 'circular' is true."
				);
			}
			animationParam.depaPos = pos;
			animationParam.startTime = new Date().getTime();
			this._status.animationParam = animationParam;
			if (retTrigger) {
				if (animationParam.duration) {
					// console.error("depaPos", pos, "depaPos",destPos, "duration", duration, "ms");
					var info = this._status.animationParam;
					var self = this;
					(function loop() {
						self._raf = null;
						if (self._frame(info) >= 1) {
							return done(true);
						} // animationEnd
						self._raf = ns.requestAnimationFrame(loop);
					})();
				} else {
					this._triggerChange(animationParam.destPos, false);
					done(!isBounce);
				}
			}
		},

		// animation frame (0~1)
		_frame: function(param) {
			var curTime = new Date() - param.startTime;
			var easingPer = this._easing(curTime / param.duration);
			var pos = [ param.depaPos[0], param.depaPos[1] ];

			for (var i = 0; i &lt; 2 ; i++) {
				(pos[i] !== param.destPos[i]) &&
				(pos[i] += (param.destPos[i] - pos[i]) * easingPer);
			}
			pos = this._getCircularPos(pos);
			this._triggerChange(pos, false);
			return easingPer;
		},

		// set up 'css' expression
		_reviseOptions: function(options) {
			var key;
			$.each(["bounce", "margin", "circular"], function(i, v) {
				key = options[v];
				if (key != null) {
					if ($.isArray(key)) {
						options[v] = key.length === 2 ?
							key.concat(key) : key.concat();
					} else if (/string|number|boolean/.test(typeof key)) {
						options[v] = [ key, key, key, key ];
					} else {
						options[v] = null;
					}
				}
			});
			$.extend(this.options, options);
		},

		// trigger 'change' event
		_triggerChange: function(pos, holding, e) {
			/**
			 * When coordinate was changed
			 * @ko 좌표가 변경됐을 때 발생한다.
			 * @name eg.MovableCoord#change
			 * @event
			 *
			 * @param {Object} param
			 * @param {Array} param.pos departure coordinate  &lt;ko>좌표&lt;/ko>
			 * @param {Number} param.pos.0 departure x-coordinate &lt;ko>x 좌표&lt;/ko>
			 * @param {Number} param.pos.1 departure y-coordinate &lt;ko>y 좌표&lt;/ko>
			 * @param {Boolean} param.holding If an area was pressed, this value is 'true'. &lt;ko>스크린을 사용자가 누르고 있을 경우 true &lt;/ko>
			 * @param {Object} param.hammerEvent Hammerjs event. if you use api, this value is null. http://hammerjs.github.io/api/#hammer.input-event &lt;ko>사용자의 액션에 대한 hammerjs 이벤트 정보 (API에 의해 호출될 경우, null 을 반환)&lt;/ko>
			 *
			 */
			this._pos = pos.concat();
			this.trigger("change", {
				pos: pos.concat(),
				holding: holding,
				hammerEvent: e || null
			});
		},

		/**
		 * Get current position
		 * @ko 현재 위치를 반환한다.
		 * @method eg.MovableCoord#get
		 * @return {Array} pos
		 * @return {Number} pos.0 x position
		 * @return {Number} pos.1 y position
		 */
		get: function() {
			return this._pos.concat();
		},

		/**
		 * Set to absolute position
		 *
		 * When duration is greater than zero, 'change' event is triggered
		 * @ko 위치를 설정한다. 만약, duration이 0보다 크다면 'change' 이벤트가 발생한다.
		 * @method eg.MovableCoord#setTo
		 * @param {Number} x x-coordinate &lt;ko>이동할 x좌표&lt;/ko>
		 * @param {Number} y y-coordinate &lt;ko>이동할 y좌표&lt;/ko>
		 * @param {Number} [duration=0] Duration of animation in milliseconds. &lt;ko>애니메이션 진행시간(ms)&lt;/ko>
		 * @return {eg.MovableCoord} instance of itself&lt;ko>자신의 인스턴스&lt;/ko>
		 */
		setTo: function(x, y, duration) {
			this._grab();
			var pos = this._pos.concat();
			var circular = this.options.circular;
			var min = this.options.min;
			var max = this.options.max;
			if (x === pos[0] && y === pos[1]) {
				return this;
			}
			this._setInterrupt(true);
			if (x !== pos[0]) {
				if (!circular[3]) {
					x = Math.max(min[0], x);
				}
				if (!circular[1]) {
					x = Math.min(max[0], x);
				}
			}
			if (y !== pos[1]) {
				if (!circular[0]) {
					y = Math.max(min[1], y);
				}
				if (!circular[2]) {
					y = Math.min(max[1], y);
				}
			}
			if (duration) {
				this._animateTo([ x, y ], this._animationEnd, false, duration);
			} else {
				this._pos = this._getCircularPos([ x, y ]);
				this._triggerChange(this._pos, false);
				this._setInterrupt(false);
			}
			return this;
		},
		/**
		 * Set to relative position
		 *
		 * When duration is greater than zero, 'change' event is triggered
		 * @ko 현재를 기준으로 위치를 설정한다. 만약, duration이 0보다 크다면 'change' 이벤트가 발생한다.
		 * @method eg.MovableCoord#setBy
		 * @param {Number} x x-coordinate &lt;ko>이동할 x좌표&lt;/ko>
		 * @param {Number} y y-coordinate &lt;ko>이동할 y좌표&lt;/ko>
		 * @param {Number} [duration=0] Duration of animation in milliseconds. &lt;ko>애니메이션 진행시간(ms)&lt;/ko>
		 * @return {eg.MovableCoord} instance of itself&lt;ko>자신의 인스턴스&lt;/ko>
		 */
		setBy: function(x, y, duration) {
			return this.setTo(
				x != null ? this._pos[0] + x : this._pos[0],
				y != null ? this._pos[1] + y : this._pos[1],
				duration
			);
		},

		_easing: function(p) {
			return p > 1 ? 1 : this.options.easing(p, p, 0, 1, 1);
		},

		_initSlope: function() {
			var easing = this.options.easing;
			var isIn = false;
			var p;
			for (p in $.easing) {
				if ($.easing[p] === easing) {
					isIn = !~p.indexOf("Out");
					break;
				}
			}
			return isIn ?
					easing(0.9999, 0.9999, 0, 1, 1) / 0.9999 :
					easing(0.00001, 0.00001, 0, 1, 1) / 0.00001;
		},

		_setInterrupt: function(prevented) {
			!this._subOptions.interruptable &&
			(this._status.prevented = prevented);
		},

		/**
		 * Release resources and unbind custom events
		 * @ko 모든 커스텀 이벤트와 자원을 해제한다.
		 * @method eg.MovableCoord#destroy
		 */
		destroy: function() {
			this.off();
			for (var p in this._hammers) {
				this._hammers[p].destroy();
				this._hammers[p] = null;
			}
		}
	});
	MC._KEY = "__MOVABLECOORD__";
	/**
	 * @name eg.MovableCoord.DIRECTION_NONE
	 * @constant
	 * @type {Number}
	 */
	MC.DIRECTION_NONE = 1;
	/**
	 * @name eg.MovableCoord.DIRECTION_LEFT
	 * @constant
	 * @type {Number}
	*/
	MC.DIRECTION_LEFT = 2;
	/**
	 * @name eg.MovableCoord.DIRECTION_RIGHT
	 * @constant
	 * @type {Number}
	*/
	MC.DIRECTION_RIGHT = 4;
	/**
	 * @name eg.MovableCoord.DIRECTION_UP
	 * @constant
	 * @type {Number}
	  */
	MC.DIRECTION_UP = 8;
	/**
	 * @name eg.MovableCoord.DIRECTION_DOWN
	 * @constant
	 * @type {Number}
	*/
	MC.DIRECTION_DOWN = 16;
	/**
	 * @name eg.MovableCoord.DIRECTION_HORIZONTAL
	 * @constant
	 * @type {Number}
	*/
	MC.DIRECTION_HORIZONTAL = 2 | 4;
	/**
	 * @name eg.MovableCoord.DIRECTION_VERTICAL
	 * @constant
	 * @type {Number}
	*/
	MC.DIRECTION_VERTICAL = 8 | 16;

	/**
	 * @name eg.MovableCoord.DIRECTION_ALL
	 * @constant
	 * @type {Number}
	*/
	MC.DIRECTION_ALL = MC.DIRECTION_HORIZONTAL | MC.DIRECTION_VERTICAL;

	return {
		"MovableCoord": ns.MovableCoord
	};
});</code></pre>
        </article>
    </section>






        
        <!-- disqus code -->
        <div id="disqus_thread"></div>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        <!-- // disqus code -->
        

        <footer>
            Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Mon Mar 14 2016 14:40:25 GMT+0900 (KST)
        </footer>
    </div>
</div>
<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/main.js"></script>
</body>
</html>
